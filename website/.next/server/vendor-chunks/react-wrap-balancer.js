"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-wrap-balancer";
exports.ids = ["vendor-chunks/react-wrap-balancer"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-wrap-balancer/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/react-wrap-balancer/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Balancer: () => (/* binding */ P),\n/* harmony export */   Provider: () => (/* binding */ Y),\n/* harmony export */   \"default\": () => (/* binding */ A)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ Balancer,Provider,default auto */ \n\nvar E = \"undefined\" == \"undefined\", m = E ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect, B = 0, _ = ()=>++B, v = !1;\nfunction O() {\n    let [n, r] = react__WEBPACK_IMPORTED_MODULE_0__.useState(v ? _ : void 0);\n    return m(()=>{\n        n === void 0 && r(_()), v = !0;\n    }, []), n === void 0 ? n : `rwb-${n.toString(32)}`;\n}\nfunction R() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"R.useMemo\": ()=>\"useId\" in react__WEBPACK_IMPORTED_MODULE_0__ ? react__WEBPACK_IMPORTED_MODULE_0__.useId : O\n    }[\"R.useMemo\"], [])();\n}\nvar y = \"__wrap_b\", f = \"__wrap_n\", S = \"__wrap_o\", T = (n, r, e)=>{\n    e = e || document.querySelector(`[data-br=\"${n}\"]`);\n    let t = e == null ? void 0 : e.parentElement;\n    if (!t) return;\n    let l = (u)=>e.style.maxWidth = u + \"px\";\n    e.style.maxWidth = \"\";\n    let i = t.clientWidth, d = t.clientHeight, o = i / 2 - .25, s = i + .5, c;\n    if (i) {\n        for(l(o), o = Math.max(e.scrollWidth, o); o + 1 < s;)c = Math.round((o + s) / 2), l(c), t.clientHeight === d ? s = c : o = c;\n        l(s * r + i * (1 - r));\n    }\n    e.__wrap_o || (typeof ResizeObserver != \"undefined\" ? (e.__wrap_o = new ResizeObserver(()=>{\n        self.__wrap_b(0, +e.dataset.brr, e);\n    })).observe(t) :  true && console.warn(\"The browser you are using does not support the ResizeObserver API. Please consider add polyfill for this API to avoid potential layout shifts or upgrade your browser. Read more: https://github.com/shuding/react-wrap-balancer#browser-support-information\"));\n}, I = T.toString(), w = '(self.CSS&&CSS.supports(\"text-wrap\",\"balance\")?1:2)', g = (n, r, e = \"\")=>(e && (e = `self.${f}!=1&&${e}`), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"script\", {\n        suppressHydrationWarning: !0,\n        dangerouslySetInnerHTML: {\n            __html: (n ? \"\" : `self.${f}=self.${f}||${w};self.${y}=${I};`) + e\n        },\n        nonce: r\n    })), h = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    preferNative: !0,\n    hasProvider: !1\n}), Y = ({ preferNative: n = !0, nonce: r, children: e })=>{\n    let t = react__WEBPACK_IMPORTED_MODULE_0__.useMemo({\n        \"Y.useMemo[t]\": ()=>({\n                preferNative: n,\n                hasProvider: !0\n            })\n    }[\"Y.useMemo[t]\"], [\n        n\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(h.Provider, {\n        value: t\n    }, g(!1, r), e);\n}, P = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ ratio: n = 1, preferNative: r, nonce: e, children: t, as: l, ...i }, d)=>{\n    let o = R(), s = react__WEBPACK_IMPORTED_MODULE_0__.useRef(), c = react__WEBPACK_IMPORTED_MODULE_0__.useContext(h), u = r != null ? r : c.preferNative, x = l || \"span\";\n    return react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(d, {\n        \"P.useImperativeHandle\": ()=>s.current\n    }[\"P.useImperativeHandle\"], []), m(()=>{\n        u && self[f] === 1 || s.current && (self[y] = T)(0, n, s.current);\n    }, [\n        t,\n        u,\n        n\n    ]), m(()=>{\n        if (!(u && self[f] === 1)) return ()=>{\n            if (!s.current) return;\n            let b = s.current[S];\n            b && (b.disconnect(), delete s.current[S]);\n        };\n    }, [\n        u\n    ]),  true && t && !Array.isArray(t) && typeof t == \"object\" && \"type\" in t && typeof t.type == \"string\" && t.type !== \"span\" && console.warn(`<Balancer> should not wrap <${t.type}> inside. Instead, it should directly wrap text or inline nodes.\n\nTry changing this:\n  <Balancer><${t.type}>content</${t.type}></Balancer>\nTo:\n  <${t.type}><Balancer>content</Balancer></${t.type}>`), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(x, {\n        ...i,\n        \"data-br\": o,\n        \"data-brr\": n,\n        ref: s,\n        style: {\n            display: \"inline-block\",\n            verticalAlign: \"top\",\n            textDecoration: \"inherit\",\n            textWrap: u ? \"balance\" : \"initial\"\n        },\n        suppressHydrationWarning: !0\n    }, t), g(c.hasProvider, e, `self.${y}(\"${o}\",${n})`));\n});\nif (!E && \"development\" !== \"production\") {\n    let n = document.querySelector(\"[data-next-hide-fouc]\");\n    if (n) {\n        let r = (t)=>{\n            for (let l of t)for (let i of Array.from(l.removedNodes)){\n                if (i !== n) continue;\n                e.disconnect();\n                let d = document.querySelectorAll(\"[data-br]\");\n                for (let o of Array.from(d))self[y](0, +o.dataset.brr, o);\n            }\n        }, e = new MutationObserver(r);\n        e.observe(document.head, {\n            childList: !0\n        });\n    }\n}\nvar A = P;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtd3JhcC1iYWxhbmNlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OytFQ0FBO0FBQWtCO0FBRVgsSUFBTUMsSUFBWSxPQUFPLFFBQVcsYUFDOUJDLElBQTRCRCxJQUNyQ0EsNENBQU0sR0FDTkEsa0RBQU0sRUFFTkUsSUFBSyxHQUNIQyxJQUFRLElBQU0sRUFBRUQsR0FDbEJFLElBQXdCO0FBRTVCLFNBQVNDLEdBQWdCO0lBQ3ZCLElBQU0sQ0FBQ0MsR0FBSUMsQ0FBSyxJQUFJUCwyQ0FBTSxDQUFTSSxJQUF3QkQsSUFBUSxNQUFTO0lBVTVFLE9BUkFGLEVBQTBCLElBQU07UUFDMUJLLE1BQU8sVUFDVEMsRUFBTUosRUFBTSxDQUFDLEdBR2ZDLElBQXdCO0lBQzFCLEdBQUcsQ0FBQyxDQUFDLEdBRURFLE1BQU8sU0FDRkEsSUFHRixPQUFPQSxFQUFHLFNBQVMsRUFBRTtBQUM5QjtBQWFPLFNBQVNFLEdBQVE7SUFNdEIsT0FMdUJSLDBDQUFNO3FCQUFRLElBQy9CLDZDQUFXRCxHQUFjQyx3Q0FBTSxHQUM1Qks7b0JBQ04sQ0FBQyxDQUFDLEVBRWlCO0FBQ3hCO0FEMUNBLElBQU1JLElBQWEsWUFDYkMsSUFBb0IsWUFDcEJDLElBQXNCLFlBdUJ0QkMsSUFBdUIsQ0FBQ04sR0FBSU8sR0FBT0MsSUFBWTtJQUNuREEsSUFDRUEsS0FBVyxTQUFTLGNBQThCLGFBQWFSLEVBQUFBLEVBQUFBLENBQU07SUFDdkUsSUFBTVMsSUFBWUQsS0FBQSxnQkFBQUEsRUFBUztJQUUzQixJQUFJLENBQUNDLEdBQWE7SUFFbEIsSUFBTUMsSUFBVUMsS0FBbUJILEVBQVEsTUFBTSxXQUFXRyxJQUFRO0lBR3BFSCxFQUFRLE1BQU0sV0FBVztJQUd6QixJQUFNRyxJQUFRRixFQUFVLGFBQ2xCRyxJQUFTSCxFQUFVLGNBR3JCSSxJQUFnQkYsSUFBUSxJQUFJLEtBQzVCRyxJQUFnQkgsSUFBUSxJQUN4Qkk7SUFFSixJQUFJSixH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QUFBO0FBQUE7QUFJdkQsSUFBT0csSUFBUWhCO0FBQUFBIiwic291cmNlcyI6WyIvaG9tZS91c2VyL3dhcnAtYWdlbnQtc3lzdGVtL3NyYy9pbmRleC50c3giLCIvaG9tZS91c2VyL3dhcnAtYWdlbnQtc3lzdGVtL3NyYy91dGlscy50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZUlkLCBJU19TRVJWRVIsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuL3V0aWxzJ1xuXG5jb25zdCBTWU1CT0xfS0VZID0gJ19fd3JhcF9iJ1xuY29uc3QgU1lNQk9MX05BVElWRV9LRVkgPSAnX193cmFwX24nXG5jb25zdCBTWU1CT0xfT0JTRVJWRVJfS0VZID0gJ19fd3JhcF9vJ1xuXG5pbnRlcmZhY2UgV3JhcHBlckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIFtTWU1CT0xfT0JTRVJWRVJfS0VZXT86IFJlc2l6ZU9ic2VydmVyIHwgdW5kZWZpbmVkXG59XG5cbnR5cGUgUmVsYXlvdXRGbiA9IChcbiAgaWQ6IHN0cmluZyB8IG51bWJlcixcbiAgcmF0aW86IG51bWJlcixcbiAgd3JhcHBlcj86IFdyYXBwZXJFbGVtZW50XG4pID0+IHZvaWRcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBbU1lNQk9MX0tFWV06IFJlbGF5b3V0Rm5cbiAgICAvLyBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0ZXh0LWJhbGFuY2luZyBuYXRpdmVseS5cbiAgICAvLyB1bmRlZmluZWQ6IG5vdCBpbmplY3RlZFxuICAgIC8vIDE6IGluamVjdGVkIGFuZCBzdXBwb3J0ZWRcbiAgICAvLyAyOiBpbmplY3RlZCBidXQgbm90IHN1cHBvcnRlZFxuICAgIFtTWU1CT0xfTkFUSVZFX0tFWV0/OiBudW1iZXJcbiAgfVxufVxuXG5jb25zdCByZWxheW91dDogUmVsYXlvdXRGbiA9IChpZCwgcmF0aW8sIHdyYXBwZXIpID0+IHtcbiAgd3JhcHBlciA9XG4gICAgd3JhcHBlciB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPFdyYXBwZXJFbGVtZW50PihgW2RhdGEtYnI9XCIke2lkfVwiXWApXG4gIGNvbnN0IGNvbnRhaW5lciA9IHdyYXBwZXI/LnBhcmVudEVsZW1lbnRcblxuICBpZiAoIWNvbnRhaW5lcikgeyByZXR1cm47IH1cblxuICBjb25zdCB1cGRhdGUgPSAod2lkdGg6IG51bWJlcikgPT4gKHdyYXBwZXIuc3R5bGUubWF4V2lkdGggPSB3aWR0aCArICdweCcpXG5cbiAgLy8gUmVzZXQgd3JhcHBlciB3aWR0aFxuICB3cmFwcGVyLnN0eWxlLm1heFdpZHRoID0gJydcblxuICAvLyBHZXQgdGhlIGluaXRpYWwgY29udGFpbmVyIHNpemVcbiAgY29uc3Qgd2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGhcbiAgY29uc3QgaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodFxuXG4gIC8vIFN5bmNocm9ub3VzbHkgZG8gYmluYXJ5IHNlYXJjaCBhbmQgY2FsY3VsYXRlIHRoZSBsYXlvdXRcbiAgbGV0IGxvd2VyOiBudW1iZXIgPSB3aWR0aCAvIDIgLSAwLjI1XG4gIGxldCB1cHBlcjogbnVtYmVyID0gd2lkdGggKyAwLjVcbiAgbGV0IG1pZGRsZTogbnVtYmVyXG5cbiAgaWYgKHdpZHRoKSB7XG4gICAgLy8gRW5zdXJlIHdlIGRvbid0IHNlYXJjaCB3aWR0aHMgbG93ZXIgdGhhbiB3aGVuIHRoZSB0ZXh0IG92ZXJmbG93c1xuICAgIHVwZGF0ZShsb3dlcilcbiAgICBsb3dlciA9IE1hdGgubWF4KHdyYXBwZXIuc2Nyb2xsV2lkdGgsIGxvd2VyKVxuXG4gICAgd2hpbGUgKGxvd2VyICsgMSA8IHVwcGVyKSB7XG4gICAgICBtaWRkbGUgPSBNYXRoLnJvdW5kKChsb3dlciArIHVwcGVyKSAvIDIpXG4gICAgICB1cGRhdGUobWlkZGxlKVxuICAgICAgaWYgKGNvbnRhaW5lci5jbGllbnRIZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgICB1cHBlciA9IG1pZGRsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG93ZXIgPSBtaWRkbGVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgd2lkdGhcbiAgICB1cGRhdGUodXBwZXIgKiByYXRpbyArIHdpZHRoICogKDEgLSByYXRpbykpXG4gIH1cblxuICAvLyBDcmVhdGUgYSBuZXcgb2JzZXJ2ZXIgaWYgd2UgZG9uJ3QgaGF2ZSBvbmUuXG4gIC8vIE5vdGUgdGhhdCB3ZSBtdXN0IGlubGluZSB0aGUga2V5IGhlcmUgYXMgd2UgdXNlIGB0b1N0cmluZygpYCB0byBzZXJpYWxpemVcbiAgLy8gdGhlIGZ1bmN0aW9uLlxuICBpZiAoIXdyYXBwZXJbJ19fd3JhcF9vJ10pIHtcbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgOyh3cmFwcGVyWydfX3dyYXBfbyddID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgc2VsZi5fX3dyYXBfYigwLCArd3JhcHBlci5kYXRhc2V0LmJyciwgd3JhcHBlcilcbiAgICAgIH0pKS5vYnNlcnZlKGNvbnRhaW5lcilcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2lsZW50bHkgaWdub3JlIFJlc2l6ZU9ic2VydmVyIGZvciBwcm9kdWN0aW9uIGJ1aWxkc1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnVGhlIGJyb3dzZXIgeW91IGFyZSB1c2luZyBkb2VzIG5vdCBzdXBwb3J0IHRoZSBSZXNpemVPYnNlcnZlciBBUEkuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSBjb25zaWRlciBhZGQgcG9seWZpbGwgZm9yIHRoaXMgQVBJIHRvIGF2b2lkIHBvdGVudGlhbCBsYXlvdXQgc2hpZnRzIG9yIHVwZ3JhZGUgeW91ciBicm93c2VyLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaHVkaW5nL3JlYWN0LXdyYXAtYmFsYW5jZXIjYnJvd3Nlci1zdXBwb3J0LWluZm9ybWF0aW9uJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFJFTEFZT1VUX1NUUiA9IHJlbGF5b3V0LnRvU3RyaW5nKClcblxuY29uc3QgaXNUZXh0V3JhcEJhbGFuY2VTdXBwb3J0ZWQgPSBgKHNlbGYuQ1NTJiZDU1Muc3VwcG9ydHMoXCJ0ZXh0LXdyYXBcIixcImJhbGFuY2VcIik/MToyKWBcblxuY29uc3QgY3JlYXRlU2NyaXB0RWxlbWVudCA9IChcbiAgaW5qZWN0ZWQ6IGJvb2xlYW4sXG4gIG5vbmNlPzogc3RyaW5nLFxuICBzdWZmaXg6IHN0cmluZyA9ICcnXG4pID0+IHtcbiAgaWYgKHN1ZmZpeCkge1xuICAgIHN1ZmZpeCA9IGBzZWxmLiR7U1lNQk9MX05BVElWRV9LRVl9IT0xJiYke3N1ZmZpeH1gXG4gIH1cbiAgcmV0dXJuIChcbiAgICA8c2NyaXB0XG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFsYW5jZSBpbml0aWFsbHkgZm9yIFNTUlxuICAgICAgICBfX2h0bWw6XG4gICAgICAgICAgKGluamVjdGVkXG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IGBzZWxmLiR7U1lNQk9MX05BVElWRV9LRVl9PXNlbGYuJHtTWU1CT0xfTkFUSVZFX0tFWX18fCR7aXNUZXh0V3JhcEJhbGFuY2VTdXBwb3J0ZWR9O3NlbGYuJHtTWU1CT0xfS0VZfT0ke1JFTEFZT1VUX1NUUn07YCkgK1xuICAgICAgICAgIHN1ZmZpeCxcbiAgICAgIH19XG4gICAgICBub25jZT17bm9uY2V9XG4gICAgLz5cbiAgKVxufVxuXG5pbnRlcmZhY2UgQmFsYW5jZXJPd25Qcm9wczxcbiAgRWxlbWVudFR5cGUgZXh0ZW5kcyBSZWFjdC5FbGVtZW50VHlwZSA9IFJlYWN0LkVsZW1lbnRUeXBlXG4+IGV4dGVuZHMgUmVhY3QuSFRNTEF0dHJpYnV0ZXM8SFRNTEVsZW1lbnQ+IHtcbiAgLyoqXG4gICAqIFRoZSBIVE1MIHRhZyB0byB1c2UgZm9yIHRoZSB3cmFwcGVyIGVsZW1lbnQuXG4gICAqIEBkZWZhdWx0ICdzcGFuJ1xuICAgKi9cbiAgYXM/OiBFbGVtZW50VHlwZVxuICAvKipcbiAgICogVGhlIGJhbGFuY2UgcmF0aW8gb2YgdGhlIHdyYXBwZXIgd2lkdGggKDAgPD0gcmF0aW8gPD0gMSkuXG4gICAqIDAgbWVhbnMgdGhlIHdyYXBwZXIgd2lkdGggaXMgdGhlIHNhbWUgYXMgdGhlIGNvbnRhaW5lciB3aWR0aCAobm8gYmFsYW5jZSwgYnJvd3NlciBkZWZhdWx0KS5cbiAgICogMSBtZWFucyB0aGUgd3JhcHBlciB3aWR0aCBpcyB0aGUgbWluaW11bSAoZnVsbCBiYWxhbmNlLCBtb3N0IGNvbXBhY3QpLlxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICByYXRpbz86IG51bWJlclxuICAvKipcbiAgICogQW4gb3B0aW9uIHRvIHNraXAgdGhlIHJlLWJhbGFuY2UgbG9naWNcbiAgICogYW5kIHVzZSB0aGUgbmF0aXZlIENTUyB0ZXh0LWJhbGFuY2luZyBpZiBzdXBwb3J0ZWQuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHByZWZlck5hdGl2ZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoZSBub25jZSBhdHRyaWJ1dGUgdG8gYWxsb3dsaXN0IGlubGluZSBzY3JpcHQgaW5qZWN0aW9uIGJ5IHRoZSBjb21wb25lbnQuXG4gICAqL1xuICBub25jZT86IHN0cmluZ1xufVxuXG50eXBlIEJhbGFuY2VyUHJvcHM8RWxlbWVudFR5cGUgZXh0ZW5kcyBSZWFjdC5FbGVtZW50VHlwZT4gPVxuICBCYWxhbmNlck93blByb3BzPEVsZW1lbnRUeXBlPiAmXG4gICAgT21pdDxSZWFjdC5Db21wb25lbnRQcm9wc1dpdGhvdXRSZWY8RWxlbWVudFR5cGU+LCBrZXlvZiBCYWxhbmNlck93blByb3BzPlxuXG4vKipcbiAqIEFuIG9wdGlvbmFsIHByb3ZpZGVyIHRvIGluamVjdCB0aGUgZ2xvYmFsIHJlbGF5b3V0IGZ1bmN0aW9uLCBzbyBhbGwgY2hpbGRyZW5cbiAqIEJhbGFuY2VyIGNvbXBvbmVudHMgY2FuIHNoYXJlIGl0LlxuICovXG5jb25zdCBCYWxhbmNlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHtcbiAgcHJlZmVyTmF0aXZlOiBib29sZWFuXG4gIGhhc1Byb3ZpZGVyOiBib29sZWFuXG59Pih7IHByZWZlck5hdGl2ZTogdHJ1ZSwgaGFzUHJvdmlkZXI6IGZhbHNlIH0pXG5jb25zdCBQcm92aWRlcjogUmVhY3QuRkM8e1xuICAvKipcbiAgICogQW4gb3B0aW9uIHRvIHNraXAgdGhlIHJlLWJhbGFuY2UgbG9naWNcbiAgICogYW5kIHVzZSB0aGUgbmF0aXZlIENTUyB0ZXh0LWJhbGFuY2luZyBpZiBzdXBwb3J0ZWQuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHByZWZlck5hdGl2ZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRoZSBub25jZSBhdHRyaWJ1dGUgdG8gYWxsb3dsaXN0IGlubGluZSBzY3JpcHQgaW5qZWN0aW9uIGJ5IHRoZSBjb21wb25lbnRcbiAgICovXG4gIG5vbmNlPzogc3RyaW5nXG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlXG59PiA9ICh7IHByZWZlck5hdGl2ZSA9IHRydWUsIG5vbmNlLCBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBwcmVmZXJOYXRpdmUsXG4gICAgICBoYXNQcm92aWRlcjogdHJ1ZSxcbiAgICB9XG4gIH0sIFtwcmVmZXJOYXRpdmVdKVxuICByZXR1cm4gKFxuICAgIDxCYWxhbmNlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZX0+XG4gICAgICB7Y3JlYXRlU2NyaXB0RWxlbWVudChmYWxzZSwgbm9uY2UpfVxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQmFsYW5jZXJDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmNvbnN0IEJhbGFuY2VyID0gUmVhY3QuZm9yd2FyZFJlZihcbiAgPEVsZW1lbnRUeXBlIGV4dGVuZHMgUmVhY3QuRWxlbWVudFR5cGUgPSBSZWFjdC5FbGVtZW50VHlwZT4oXG4gICAge1xuICAgICAgcmF0aW8gPSAxLFxuICAgICAgcHJlZmVyTmF0aXZlLFxuICAgICAgbm9uY2UsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGFzLFxuICAgICAgLi4ucHJvcHNcbiAgICB9OiBCYWxhbmNlclByb3BzPEVsZW1lbnRUeXBlPixcbiAgICByZWZcbiAgKSA9PiB7XG4gICAgY29uc3QgaWQgPSB1c2VJZCgpXG4gICAgY29uc3Qgd3JhcHBlclJlZiA9IFJlYWN0LnVzZVJlZjxXcmFwcGVyRWxlbWVudD4oKVxuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQmFsYW5jZXJDb250ZXh0KVxuICAgIGNvbnN0IHByZWZlck5hdGl2ZUJhbGFuY2luZyA9IHByZWZlck5hdGl2ZSA/PyBjb250ZXh0VmFsdWUucHJlZmVyTmF0aXZlXG4gICAgY29uc3QgV3JhcHBlcjogUmVhY3QuRWxlbWVudFR5cGUgPSBhcyB8fCAnc3BhbidcblxuICAgIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiB3cmFwcGVyUmVmLmN1cnJlbnQsIFtdKVxuXG4gICAgLy8gUmUtYmFsYW5jZSBvbiBjb250ZW50IGNoYW5nZSBhbmQgb24gbW91bnQvaHlkcmF0aW9uLlxuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gU2tpcCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0ZXh0LWJhbGFuY2luZyBuYXRpdmVseS5cbiAgICAgIGlmIChwcmVmZXJOYXRpdmVCYWxhbmNpbmcgJiYgc2VsZltTWU1CT0xfTkFUSVZFX0tFWV0gPT09IDEpIHJldHVyblxuXG4gICAgICBpZiAod3JhcHBlclJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIFJlLWFzc2lnbiB0aGUgZnVuY3Rpb24gaGVyZSBhcyB0aGUgY29tcG9uZW50IGNhbiBiZSBkeW5hbWljYWxseSByZW5kZXJlZCwgYW5kIHNjcmlwdCB0YWcgd29uJ3Qgd29yayBpbiB0aGF0IGNhc2UuXG4gICAgICAgIDsoc2VsZltTWU1CT0xfS0VZXSA9IHJlbGF5b3V0KSgwLCByYXRpbywgd3JhcHBlclJlZi5jdXJyZW50KVxuICAgICAgfVxuICAgIH0sIFtjaGlsZHJlbiwgcHJlZmVyTmF0aXZlQmFsYW5jaW5nLCByYXRpb10pXG5cbiAgICAvLyBSZW1vdmUgdGhlIG9ic2VydmVyIHdoZW4gdW5tb3VudGluZy5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIFNraXAgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGV4dC1iYWxhbmNpbmcgbmF0aXZlbHkuXG4gICAgICBpZiAocHJlZmVyTmF0aXZlQmFsYW5jaW5nICYmIHNlbGZbU1lNQk9MX05BVElWRV9LRVldID09PSAxKSByZXR1cm5cblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCF3cmFwcGVyUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gd3JhcHBlclJlZi5jdXJyZW50W1NZTUJPTF9PQlNFUlZFUl9LRVldXG4gICAgICAgIGlmICghcmVzaXplT2JzZXJ2ZXIpIHJldHVyblxuXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICBkZWxldGUgd3JhcHBlclJlZi5jdXJyZW50W1NZTUJPTF9PQlNFUlZFUl9LRVldXG4gICAgICB9XG4gICAgfSwgW3ByZWZlck5hdGl2ZUJhbGFuY2luZ10pXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBjaGVjayBgY2hpbGRyZW5gJ3MgdHlwZSB0byBlbnN1cmUgd2UgYXJlIG5vdCB3cmFwcGluZ1xuICAgICAgLy8gZWxlbWVudHMgbGlrZSA8cD4gb3IgPGgxPiBpbnNpZGUuIEluc3RlYWQgPEJhbGFuY2VyPiBzaG91bGQgZGlyZWN0bHlcbiAgICAgIC8vIHdyYXAgdGV4dCBub2Rlcy5cbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGRyZW4gJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ29iamVjdCdcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgJ3R5cGUnIGluIGNoaWxkcmVuICYmXG4gICAgICAgICAgdHlwZW9mIGNoaWxkcmVuLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgY2hpbGRyZW4udHlwZSAhPT0gJ3NwYW4nXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGA8QmFsYW5jZXI+IHNob3VsZCBub3Qgd3JhcCA8JHtjaGlsZHJlbi50eXBlfT4gaW5zaWRlLiBJbnN0ZWFkLCBpdCBzaG91bGQgZGlyZWN0bHkgd3JhcCB0ZXh0IG9yIGlubGluZSBub2Rlcy5cblxuVHJ5IGNoYW5naW5nIHRoaXM6XG4gIDxCYWxhbmNlcj48JHtjaGlsZHJlbi50eXBlfT5jb250ZW50PC8ke2NoaWxkcmVuLnR5cGV9PjwvQmFsYW5jZXI+XG5UbzpcbiAgPCR7Y2hpbGRyZW4udHlwZX0+PEJhbGFuY2VyPmNvbnRlbnQ8L0JhbGFuY2VyPjwvJHtjaGlsZHJlbi50eXBlfT5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDw+XG4gICAgICAgIDxXcmFwcGVyXG4gICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgIGRhdGEtYnI9e2lkfVxuICAgICAgICAgIGRhdGEtYnJyPXtyYXRpb31cbiAgICAgICAgICByZWY9e3dyYXBwZXJSZWZ9XG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ2luaGVyaXQnLFxuICAgICAgICAgICAgdGV4dFdyYXA6IHByZWZlck5hdGl2ZUJhbGFuY2luZyA/ICdiYWxhbmNlJyA6ICdpbml0aWFsJyxcbiAgICAgICAgICB9fVxuICAgICAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1xuICAgICAgICA+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1dyYXBwZXI+XG4gICAgICAgIHtjcmVhdGVTY3JpcHRFbGVtZW50KFxuICAgICAgICAgIGNvbnRleHRWYWx1ZS5oYXNQcm92aWRlcixcbiAgICAgICAgICBub25jZSxcbiAgICAgICAgICBgc2VsZi4ke1NZTUJPTF9LRVl9KFwiJHtpZH1cIiwke3JhdGlvfSlgXG4gICAgICAgICl9XG4gICAgICA8Lz5cbiAgICApXG4gIH1cbilcblxuLy8gQXMgTmV4dC5qcyBhZGRzIGBkaXNwbGF5OiBub25lYCB0byBgYm9keWAgZm9yIGRldmVsb3BtZW50LCB3ZSBuZWVkIHRvIHRyaWdnZXJcbi8vIGEgcmUtYmFsYW5jZSByaWdodCBhZnRlciB0aGUgc3R5bGUgaXMgcmVtb3ZlZCwgc3luY2hyb25vdXNseS5cbmlmICghSVNfU0VSVkVSICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY29uc3QgbmV4dF9kZXZfc3R5bGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yPEhUTUxFbGVtZW50PihcbiAgICAnW2RhdGEtbmV4dC1oaWRlLWZvdWNdJ1xuICApXG4gIGlmIChuZXh0X2Rldl9zdHlsZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrOiBNdXRhdGlvbkNhbGxiYWNrID0gKG11dGF0aW9uTGlzdCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbkxpc3QpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIEFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKSkge1xuICAgICAgICAgIGlmIChub2RlICE9PSBuZXh0X2Rldl9zdHlsZSkgY29udGludWVcblxuICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID1cbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGw8V3JhcHBlckVsZW1lbnQ+KCdbZGF0YS1icl0nKVxuXG4gICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIEFycmF5LmZyb20oZWxlbWVudHMpKSB7XG4gICAgICAgICAgICBzZWxmW1NZTUJPTF9LRVldKDAsICtlbGVtZW50LmRhdGFzZXQuYnJyLCBlbGVtZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKVxuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuaGVhZCwgeyBjaGlsZExpc3Q6IHRydWUgfSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYWxhbmNlclxuZXhwb3J0IHsgUHJvdmlkZXIsIEJhbGFuY2VyLCBCYWxhbmNlck93blByb3BzIH1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IElTX1NFUlZFUiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG5leHBvcnQgY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IElTX1NFUlZFUlxuICA/IFJlYWN0LnVzZUVmZmVjdFxuICA6IFJlYWN0LnVzZUxheW91dEVmZmVjdFxuXG5sZXQgSUQgPSAwXG5jb25zdCBnZW5JZCA9ICgpID0+ICsrSURcbmxldCBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPSBmYWxzZVxuXG5mdW5jdGlvbiB1c2VJZFBvbHlmaWxsKCkge1xuICBjb25zdCBbaWQsIHNldElkXSA9IFJlYWN0LnVzZVN0YXRlKHNlcnZlckhhbmRvZmZDb21wbGV0ZSA/IGdlbklkIDogdW5kZWZpbmVkKVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXRJZChnZW5JZCgpKVxuICAgIH1cblxuICAgIHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9IHRydWVcbiAgfSwgW10pXG5cbiAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIHJldHVybiBgcndiLSR7aWQudG9TdHJpbmcoMzIpfWBcbn1cblxuLyoqXG4gKiBBIGhvb2sgZm9yIGdlbmVyYXRpbmcgdW5pcXVlIElEcyB0aGF0IGFyZSBzdGFibGUgYWNyb3NzIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudCxcbiAqIHdoaWxlIGF2b2lkaW5nIGh5ZHJhdGlvbiBtaXNtYXRjaGVzLiBDb21wYXRpYmxlIHdpdGggUmVhY3QgMTYrIGJ5IHVzaW5nXG4gKiBbUmVhY3QgMTgncyB1c2VJZF0oaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2hvb2tzLXJlZmVyZW5jZS5odG1sI3VzZWlkKSBpZlxuICogaXQncyBhdmFpbGFibGUsIGFuZCBhIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIGluc3BpcmVkIGJ5XG4gKiBbQGFjY2Vzc2libGUvdXNlLWlkXShodHRwczovL2dpdGh1Yi5jb20vYWNjZXNzaWJsZS11aS91c2UtaWQpIGlmIGl0IGlzIG5vdC5cbiAqXG4gKiBcInJ3Yi1cIiBpcyBoYXJkLWNvZGVkIGFzIGEgcHJlZml4IGluIHRoZSBwb2x5ZmlsbC4gV2hlbiB1c2luZyBSZWFjdCAxOCssXG4gKiBhIHByZWZpeCBjYW4gYmUgcHJvdmlkZWQgd2l0aCB0aGUgYGlkZW50aWZpZXJQcmVmaXhgIG9wdGlvbiBpblxuICogW1JlYWN0RE9NQ2xpZW50XShodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLWNsaWVudC5odG1sKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUlkKCkge1xuICBjb25zdCBpbXBsZW1lbnRhdGlvbiA9IFJlYWN0LnVzZU1lbW8oKCk6ICgoKSA9PiBzdHJpbmcgfCBudW1iZXIpID0+IHtcbiAgICBpZiAoJ3VzZUlkJyBpbiBSZWFjdCkgcmV0dXJuIFJlYWN0LnVzZUlkXG4gICAgcmV0dXJuIHVzZUlkUG9seWZpbGxcbiAgfSwgW10pXG5cbiAgcmV0dXJuIGltcGxlbWVudGF0aW9uKClcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIklTX1NFUlZFUiIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJJRCIsImdlbklkIiwic2VydmVySGFuZG9mZkNvbXBsZXRlIiwidXNlSWRQb2x5ZmlsbCIsImlkIiwic2V0SWQiLCJ1c2VJZCIsIlNZTUJPTF9LRVkiLCJTWU1CT0xfTkFUSVZFX0tFWSIsIlNZTUJPTF9PQlNFUlZFUl9LRVkiLCJyZWxheW91dCIsInJhdGlvIiwid3JhcHBlciIsImNvbnRhaW5lciIsInVwZGF0ZSIsIndpZHRoIiwiaGVpZ2h0IiwibG93ZXIiLCJ1cHBlciIsIm1pZGRsZSIsIlJFTEFZT1VUX1NUUiIsImlzVGV4dFdyYXBCYWxhbmNlU3VwcG9ydGVkIiwiY3JlYXRlU2NyaXB0RWxlbWVudCIsImluamVjdGVkIiwibm9uY2UiLCJzdWZmaXgiLCJCYWxhbmNlckNvbnRleHQiLCJQcm92aWRlciIsInByZWZlck5hdGl2ZSIsImNoaWxkcmVuIiwiY29udGV4dFZhbHVlIiwiQmFsYW5jZXIiLCJhcyIsInByb3BzIiwicmVmIiwid3JhcHBlclJlZiIsInByZWZlck5hdGl2ZUJhbGFuY2luZyIsIldyYXBwZXIiLCJyZXNpemVPYnNlcnZlciIsIm5leHRfZGV2X3N0eWxlIiwiY2FsbGJhY2siLCJtdXRhdGlvbkxpc3QiLCJtdXRhdGlvbiIsIm5vZGUiLCJvYnNlcnZlciIsImVsZW1lbnRzIiwiZWxlbWVudCIsInNyY19kZWZhdWx0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-wrap-balancer/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/react-wrap-balancer/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/react-wrap-balancer/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Balancer: () => (/* binding */ Balancer),
/* harmony export */   Provider: () => (/* binding */ Provider),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-server-dom-webpack/server.edge */ "(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-webpack-server-edge.js");

const Balancer = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call Balancer() from the server but Balancer is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/home/user/warp-agent-system/website/node_modules/react-wrap-balancer/dist/index.mjs",
"Balancer",
);const Provider = (0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call Provider() from the server but Provider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/home/user/warp-agent-system/website/node_modules/react-wrap-balancer/dist/index.mjs",
"Provider",
);/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_server_dom_webpack_server_edge__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(
function() { throw new Error("Attempted to call the default export of \"/home/user/warp-agent-system/website/node_modules/react-wrap-balancer/dist/index.mjs\" from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component."); },
"/home/user/warp-agent-system/website/node_modules/react-wrap-balancer/dist/index.mjs",
"default",
));


/***/ })

};
;